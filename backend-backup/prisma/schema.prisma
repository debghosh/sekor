// Prisma Schema for Sekor-BKC Production
// Multi-content-type support: Articles, Podcasts, Vlogs, Photo Essays

generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// ENUMS
// ============================================================================

enum Role {
  READER
  AUTHOR
  EDITOR
  ADMIN
}

enum UserStatus {
  ACTIVE
  SUSPENDED
  DELETED
}

enum ContentType {
  ARTICLE
  PODCAST
  VLOG
  PHOTO_ESSAY
}

enum ContentStatus {
  DRAFT
  REVIEW
  PUBLISHED
  ARCHIVED
}

enum SubscriptionPlan {
  FREE
  PREMIUM
}

enum SubscriptionFrequency {
  DAILY
  WEEKLY
}

enum SubscriptionStatus {
  ACTIVE
  CANCELED
  PAUSED
}

enum EngagementType {
  VIEW
  LIKE
  SHARE
  COMMENT
  SAVE
}

// ============================================================================
// USER MODELS
// ============================================================================

model User {
  id                   String         @id @default(uuid())
  email                String         @unique
  name                 String
  passwordHash         String?        @map("password_hash")
  role                 Role       @default(READER)
  avatarUrl            String?        @map("avatar_url")
  bio                  String?
  emailVerified        Boolean        @default(false) @map("email_verified")
  verificationToken    String?        @unique @map("verification_token")
  resetToken           String?        @unique @map("reset_token")
  resetTokenExpires    DateTime?      @map("reset_token_expires")
  status               UserStatus     @default(ACTIVE)
  lastLogin            DateTime?      @map("last_login")
  createdAt            DateTime       @default(now()) @map("created_at")
  updatedAt            DateTime       @updatedAt @map("updated_at")

  // Relations
  content              Content[]
  subscription         Subscription?
  followers            UserFollow[]   @relation("following")
  following            UserFollow[]   @relation("follower")
  savedContent         SavedContent[]
  engagement           ContentEngagement[]
  notifications        Notification[]
  comments             Comment[]


  @@index([email])
  @@index([role])
  @@index([status])
  @@map("users")
}

model UserFollow {
  followerId  String   @map("follower_id")
  followingId String   @map("following_id")
  createdAt   DateTime @default(now()) @map("created_at")

  follower    User     @relation("follower", fields: [followerId], references: [id], onDelete: Cascade)
  following   User     @relation("following", fields: [followingId], references: [id], onDelete: Cascade)

  @@id([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
  @@map("user_follows")
}

// ============================================================================
// CONTENT MODELS (Multi-type support)
// ============================================================================

model Content {
  id              String        @id @default(uuid())
  type            ContentType   @default(ARTICLE)
  title           String
  slug            String        @unique
  summary         String?       @db.Text
  
  // Common fields for all content types
  categoryId      String        @map("category_id")
  authorId        String        @map("author_id")
  status          ContentStatus @default(DRAFT)
  publishDate     DateTime?     @map("publish_date")
  views           Int           @default(0)
  
  // Type-specific data stored as JSONB
  // Structure varies by content type (Article, Podcast, Vlog, Photo Essay)
  typeData        Json          @map("type_data")
  
  // SEO fields
  seoTitle        String?       @map("seo_title")
  seoDescription  String?       @map("seo_description")
  seoKeywords     String[]      @map("seo_keywords")
  
  // Timestamps
  createdAt       DateTime      @default(now()) @map("created_at")
  updatedAt       DateTime      @updatedAt @map("updated_at")

  // Relations
  category        Category              @relation(fields: [categoryId], references: [id])
  author          User                  @relation(fields: [authorId], references: [id], onDelete: Cascade)
  savedBy         SavedContent[]
  engagement      ContentEngagement[]
  tags            ContentTag[]
  comments        Comment[]

  @@index([authorId])
  @@index([categoryId])
  @@index([status])
  @@index([type])
  @@index([slug])
  @@index([publishDate])
  @@map("content")
}

model Category {
  id          String    @id @default(uuid())
  name        String
  slug        String    @unique
  nameBengali String?   @map("name_bengali") // Bengali translation
  description String?   @db.Text
  parentId    String?   @map("parent_id")
  order       Int       @default(0)
  createdAt   DateTime  @default(now()) @map("created_at")

  // Relations
  parent      Category?  @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children    Category[] @relation("CategoryHierarchy")
  content     Content[]

  @@index([slug])
  @@index([parentId])
  @@map("categories")
}

model Tag {
  id        String       @id @default(uuid())
  name      String       @unique
  slug      String       @unique
  createdAt DateTime     @default(now()) @map("created_at")

  // Relations
  content   ContentTag[]

  @@index([slug])
  @@map("tags")
}

model ContentTag {
  contentId String  @map("content_id")
  tagId     String  @map("tag_id")

  content   Content @relation(fields: [contentId], references: [id], onDelete: Cascade)
  tag       Tag     @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([contentId, tagId])
  @@index([contentId])
  @@index([tagId])
  @@map("content_tags")
}

// ============================================================================
// ENGAGEMENT MODELS
// ============================================================================

model SavedContent {
  userId    String   @map("user_id")
  contentId String   @map("content_id")
  tags      String[]
  notes     String?  @db.Text
  createdAt DateTime @default(now()) @map("created_at")

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  content   Content  @relation(fields: [contentId], references: [id], onDelete: Cascade)

  @@id([userId, contentId])
  @@index([userId])
  @@index([contentId])
  @@map("saved_content")
}

model ContentEngagement {
  id             String         @id @default(uuid())
  contentId      String         @map("content_id")
  userId         String?        @map("user_id")
  engagementType EngagementType @map("engagement_type")
  metadata       Json?
  createdAt      DateTime       @default(now()) @map("created_at")

  content        Content        @relation(fields: [contentId], references: [id], onDelete: Cascade)
  user           User?          @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([contentId])
  @@index([userId])
  @@index([engagementType])
  @@index([createdAt])
  @@map("content_engagement")
}

model Comment {
  id        String   @id @default(uuid())
  contentId String   @map("content_id")
  userId    String   @map("user_id")
  parentId  String?  @map("parent_id") // For nested comments
  text      String   @db.Text
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  content   Content   @relation(fields: [contentId], references: [id], onDelete: Cascade)
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  parent    Comment?  @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies   Comment[] @relation("CommentReplies")

  @@index([contentId])
  @@index([userId])
  @@index([parentId])
  @@index([createdAt])
  @@map("comments")
}

// ============================================================================
// SUBSCRIPTION MODELS
// ============================================================================

model Subscription {
  id                    String               @id @default(uuid())
  userId                String               @unique @map("user_id")
  plan                  SubscriptionPlan     @default(FREE)
  frequency             SubscriptionFrequency?
  interests             String[] // Category slugs or content types
  stripeCustomerId      String?              @unique @map("stripe_customer_id")
  stripeSubscriptionId  String?              @unique @map("stripe_subscription_id")
  status                SubscriptionStatus   @default(ACTIVE)
  currentPeriodStart    DateTime?            @map("current_period_start")
  currentPeriodEnd      DateTime?            @map("current_period_end")
  cancelAt              DateTime?            @map("cancel_at")
  createdAt             DateTime             @default(now()) @map("created_at")
  updatedAt             DateTime             @updatedAt @map("updated_at")

  // Relations
  user                  User                 @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([stripeCustomerId])
  @@index([status])
  @@map("subscriptions")
}

// ============================================================================
// NOTIFICATION MODELS
// ============================================================================

model Notification {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  type      String
  title     String
  message   String   @db.Text
  read      Boolean  @default(false)
  metadata  Json?
  createdAt DateTime @default(now()) @map("created_at")

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([read])
  @@index([createdAt])
  @@map("notifications")
}
